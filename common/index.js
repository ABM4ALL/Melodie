/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./MelodieInfra/core/agent.js":
/*!************************************!*\
  !*** ./MelodieInfra/core/agent.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Agent\": () => (/* binding */ Agent),\n/* harmony export */   \"Element\": () => (/* binding */ Element)\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./MelodieInfra/core/types.js\");\n\nvar _pj;\nfunction _pj_snippets(container) {\n    function _assert(comp, msg) {\n        function PJAssertionError(message) {\n            this.name = \"PJAssertionError\";\n            this.message = (message || \"Custom error PJAssertionError\");\n            if (((typeof Error.captureStackTrace) === \"function\")) {\n                Error.captureStackTrace(this, this.constructor);\n            } else {\n                this.stack = new Error(message).stack;\n            }\n        }\n        PJAssertionError.prototype = Object.create(Error.prototype);\n        PJAssertionError.prototype.constructor = PJAssertionError;\n        msg = (msg || \"Assertion failed.\");\n        if ((! comp)) {\n            throw new PJAssertionError(msg);\n        }\n    }\n    function in_es6(left, right) {\n        if (((right instanceof Array) || ((typeof right) === \"string\"))) {\n            return (right.indexOf(left) > (- 1));\n        } else {\n            if (((right instanceof Map) || (right instanceof Set) || (right instanceof WeakMap) || (right instanceof WeakSet))) {\n                return right.has(left);\n            } else {\n                return (left in right);\n            }\n        }\n    }\n    container[\"_assert\"] = _assert;\n    container[\"in_es6\"] = in_es6;\n    return container;\n}\n_pj = {};\n_pj_snippets(_pj);\nclass Element {\n    set_params(params) {\n        /*\n        :param params:\n        :return:\n        */\n        var paramName, paramValue;\n        for (var item, _pj_c = 0, _pj_a = params.items(), _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {\n            item = _pj_a[_pj_c];\n            [paramName, paramValue] = item;\n            _pj._assert(_pj.in_es6(paramName, this.__dict__.keys()), `param named ${paramName}, value ${paramValue} not in Agent.params:${this.__dict__.keys()}`);\n            this[paramName] = paramValue;\n        }\n    }\n}\nclass Agent extends Element {\n    constructor(agent_id) {\n        super();\n        this.id = agent_id;\n        this.scenario = null;\n        this.model = null;\n    }\n    setup() {\n        /*\n        This is the initialization method, declare properties here.\n        Here, \"Declare\" is to define properties with zero as initial value, such as:\n        ```python\n        class NewAgent(Agent)\n        def setup(self):\n        self.int_property = 0\n        self.float_property = 0.0\n        self.str_property = \"\"\n        ```\n        It is also fine to define properties with complex data structure such as dict/list/set, but the values in the\n        complex data structure is hard to be recorded by the `DataCollector`\n        This method is executed at the end of the `__init__` method of the corresponding agent container.\n        :return:\n        */\n    }\n    __repr__() {\n        var d, k, v;\n        d = {};\n        for (var item, _pj_c = 0, _pj_a = this.__dict__.items(), _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {\n            item = _pj_a[_pj_c];\n            [k, v] = item;\n            if ((! k.startswith(\"_\"))) {\n                d[k] = v;\n            }\n        }\n        return (\"<%s %s>\" % [this.__class__.__name__, d]);\n    }\n}\n\n\n//# sourceMappingURL=agent.js.map\n\n\n//# sourceURL=webpack://leetcode/./MelodieInfra/core/agent.js?");

/***/ }),

/***/ "./MelodieInfra/core/agent_list.js":
/*!*****************************************!*\
  !*** ./MelodieInfra/core/agent_list.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AgentList\": () => (/* binding */ AgentList)\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./MelodieInfra/core/types.js\");\n/* harmony import */ var _agent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./agent */ \"./MelodieInfra/core/agent.js\");\n\n\nvar _pj;\nfunction _pj_snippets(container) {\n    function _assert(comp, msg) {\n        function PJAssertionError(message) {\n            this.name = \"PJAssertionError\";\n            this.message = (message || \"Custom error PJAssertionError\");\n            if (((typeof Error.captureStackTrace) === \"function\")) {\n                Error.captureStackTrace(this, this.constructor);\n            } else {\n                this.stack = new Error(message).stack;\n            }\n        }\n        PJAssertionError.prototype = Object.create(Error.prototype);\n        PJAssertionError.prototype.constructor = PJAssertionError;\n        msg = (msg || \"Assertion failed.\");\n        if ((! comp)) {\n            throw new PJAssertionError(msg);\n        }\n    }\n    container[\"_assert\"] = _assert;\n    return container;\n}\n_pj = {};\n_pj_snippets(_pj);\nclass SeqIter {\n    /*\n    The iterator to deal with for-loops in AgentList or other agent containers\n    */\n    constructor(seq) {\n        this._seq = seq;\n        this._i = 0;\n    }\n    __next__() {\n        var next_item;\n        if ((this._i >= this._seq.length)) {\n            throw StopIteration;\n        }\n        next_item = this._seq[this._i];\n        this._i += 1;\n        return next_item;\n    }\n}\nclass BaseAgentContainer {\n    /*\n    The base class that contains agents\n    */\n    constructor() {\n        this._id_offset = (- 1);\n        this.scenario = null;\n        this.agents = null;\n    }\n    new_id() {\n        /*\n        Create a new auto-increment ID\n        :return:\n        */\n        this._id_offset += 1;\n        return this._id_offset;\n    }\n    all_agent_ids() {\n        /*\n        Get id of all agents.\n        :return:\n        */\n        return function () {\n    var _pj_a = [], _pj_b = this.agents;\n    for (var _pj_c = 0, _pj_d = _pj_b.length; (_pj_c < _pj_d); _pj_c += 1) {\n        var agent = _pj_b[_pj_c];\n        _pj_a.push(agent.id);\n    }\n    return _pj_a;\n}\n.call(this);\n    }\n    to_list(column_names = null) {\n        /*\n        Convert all agent properties to a list of dict.\n        :param column_names:  property names\n        :return:\n        */\n    }\n    get_agent(agent_id) {\n        var index;\n        index = binary_search(this.agents, agent_id, {\"key\": (agent) => {\n    return agent.id;\n}});\n        if ((index === (- 1))) {\n            return null;\n        } else {\n            return this.agents[index];\n        }\n    }\n}\nclass AgentList extends BaseAgentContainer {\n    constructor(agent_class, length, model) {\n        super();\n        this._iter_index = 0;\n        this.scenario = model.scenario;\n        this.agent_class = agent_class;\n        this.initial_agent_num = length;\n        this.model = model;\n        this.agents = [];\n    }\n    __repr__() {\n        return `<AgentList ${this.agents}>`;\n    }\n    get length() {\n        return this.agents.length;\n    }\n    __getitem__(item) {\n        return this.agents.__getitem__(item);\n    }\n    __iter__() {\n        this._iter_index = 0;\n        return new SeqIter(this.agents);\n    }\n    init_agents() {\n        /*\n        Initialize all agents in the container, and call the `setup()` method\n        :return:\n        */\n        var agents, scenario;\n        agents = function () {\n    var _pj_a = [], _pj_b = range(this.initial_agent_num);\n    for (var _pj_c = 0, _pj_d = _pj_b.length; (_pj_c < _pj_d); _pj_c += 1) {\n        var i = _pj_b[_pj_c];\n        _pj_a.push(this.agent_class(this.new_id()));\n    }\n    return _pj_a;\n}\n.call(this);\n        scenario = this.model.scenario;\n        for (var agent, _pj_c = 0, _pj_a = agents, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {\n            agent = _pj_a[_pj_c];\n            agent.scenario = scenario;\n            agent.model = this.model;\n            agent.setup();\n        }\n        return agents;\n    }\n    random_sample(sample_num) {\n        /*\n        Randomly sample `sample_num` agents from the container\n        :param sample_num:\n        :return:\n        */\n        return random.sample(this.agents, sample_num);\n    }\n    remove(agent) {\n        /*\n        Remove the agent\n        :param agent:\n        :return:\n        */\n        var a;\n        for (var i = 0, _pj_a = this.agents.length; (i < _pj_a); i += 1) {\n            a = this.agents[i];\n            if ((a === agent)) {\n                this.agents.pop(i);\n                break;\n            }\n        }\n    }\n    add(agent = null, params = null) {\n        /*\n        Add an agent\n        :param agent:\n        :param params:\n        :return:\n        */\n        var new_id;\n        new_id = this.new_id();\n        if ((agent !== null)) {\n            _pj._assert((agent instanceof _agent__WEBPACK_IMPORTED_MODULE_1__.Agent), null);\n        } else {\n            agent = new this.agent_class(new_id);\n        }\n        agent.scenario = this.model.scenario;\n        agent.model = this.model;\n        agent.setup();\n        if ((params !== null)) {\n            _pj._assert((params instanceof dict), null);\n            if ((params.get(\"id\") !== null)) {\n                logger.warning(\"Warning, agent 'id' passed together with 'params' will be overridden by a new id generated automatically\");\n            }\n            agent.set_params(params);\n        }\n        agent.id = new_id;\n        this.agents.append(agent);\n    }\n    set_properties(props_df) {\n        /*\n        Extract properties from a dataframe, and Each row in the dataframe represents the property of an agent.\n        :param props_df:\n        :return:\n        */\n        super.set_properties(props_df);\n        this.agents.sort({\"key\": (agent) => {\n    return agent.id;\n}});\n    }\n}\n\n\n//# sourceMappingURL=agent_list.js.map\n\n\n//# sourceURL=webpack://leetcode/./MelodieInfra/core/agent_list.js?");

/***/ }),

/***/ "./MelodieInfra/core/environment.js":
/*!******************************************!*\
  !*** ./MelodieInfra/core/environment.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Environment\": () => (/* binding */ Environment)\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./MelodieInfra/core/types.js\");\n/* harmony import */ var _agent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./agent */ \"./MelodieInfra/core/agent.js\");\n\n\nclass Environment extends _agent__WEBPACK_IMPORTED_MODULE_1__.Element {\n    constructor() {\n        super();\n        this.model = null;\n        this.scenario = null;\n    }\n    setup() {\n        /*\n        The setup method of the environment.\n        Use `self.scenario` to get the parameters from the scenario.\n        :return:\n        */\n    }\n    to_dict(properties) {\n        /*\n        Dump Environment to a plain dict.\n        :param properties:\n        :return:\n        */\n        var d;\n        if ((properties === null)) {\n            properties = this.__dict__.keys();\n        }\n        d = {};\n        for (var property, _pj_c = 0, _pj_a = properties, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {\n            property = _pj_a[_pj_c];\n            d[property] = this.__dict__[property];\n        }\n        return d;\n    }\n}\n\n\n//# sourceMappingURL=environment.js.map\n\n\n//# sourceURL=webpack://leetcode/./MelodieInfra/core/environment.js?");

/***/ }),

/***/ "./MelodieInfra/core/grid.js":
/*!***********************************!*\
  !*** ./MelodieInfra/core/grid.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Grid\": () => (/* binding */ Grid),\n/* harmony export */   \"GridAgent\": () => (/* binding */ GridAgent),\n/* harmony export */   \"GridItem\": () => (/* binding */ GridItem),\n/* harmony export */   \"Spot\": () => (/* binding */ Spot)\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./MelodieInfra/core/types.js\");\n/* harmony import */ var _agent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./agent */ \"./MelodieInfra/core/agent.js\");\n\n\nvar _pj;\nfunction _pj_snippets(container) {\n    function _assert(comp, msg) {\n        function PJAssertionError(message) {\n            this.name = \"PJAssertionError\";\n            this.message = (message || \"Custom error PJAssertionError\");\n            if (((typeof Error.captureStackTrace) === \"function\")) {\n                Error.captureStackTrace(this, this.constructor);\n            } else {\n                this.stack = new Error(message).stack;\n            }\n        }\n        PJAssertionError.prototype = Object.create(Error.prototype);\n        PJAssertionError.prototype.constructor = PJAssertionError;\n        msg = (msg || \"Assertion failed.\");\n        if ((! comp)) {\n            throw new PJAssertionError(msg);\n        }\n    }\n    function in_es6(left, right) {\n        if (((right instanceof Array) || ((typeof right) === \"string\"))) {\n            return (right.indexOf(left) > (- 1));\n        } else {\n            if (((right instanceof Map) || (right instanceof _types__WEBPACK_IMPORTED_MODULE_0__.Set) || (right instanceof WeakMap) || (right instanceof WeakSet))) {\n                return right.has(left);\n            } else {\n                return (left in right);\n            }\n        }\n    }\n    container[\"_assert\"] = _assert;\n    container[\"in_es6\"] = in_es6;\n    return container;\n}\n_pj = {};\n_pj_snippets(_pj);\nclass GridItem extends _agent__WEBPACK_IMPORTED_MODULE_1__.Agent {\n    constructor(agent_id, grid, x = 0, y = 0) {\n        super(agent_id);\n        this.grid = grid;\n        this.x = x;\n        this.y = y;\n    }\n    __repr__() {\n        return `<${this.__class__.__name__} 'x': ${this.x}, 'y': ${this.y}>`;\n    }\n}\nclass GridAgent extends GridItem {\n    constructor(agent_id, x = 0, y = 0, grid = null) {\n        super(agent_id, grid, x, y);\n        this.category = (- 1);\n        this.set_category();\n        _pj._assert((this.category >= 0), \"Category should be larger or \");\n    }\n    set_category() {\n        /*\n        Set the category of GridAgent.\n\n        As there may be more than one types of agent wandering around the grid, `category` is used to tell the type of\n        `GridAgent`. So be sure to inherit this method in custom GridAgent implementation.\n\n        :return: int\n        */\n        throw new NotImplementedError(\"Category should be set for GridAgent\");\n    }\n    rand_move_agent(x_range, y_range) {\n        /*\n        Randomly move to a new position within x and y range.\n\n        :return: None\n        */\n        if ((this.grid === null)) {\n            throw new ValueError(\"Grid Agent has not been registered onto the grid!\");\n        }\n        [this.x, this.y] = this.grid.rand_move_agent(this, this.category, x_range, y_range);\n    }\n}\nclass Spot extends GridItem {\n    constructor(spot_id, grid, x = 0, y = 0) {\n        super(spot_id, grid, x, y);\n        this.grid = grid;\n        this.colormap = 0;\n    }\n    get_spot_agents() {\n        /*\n        Get all agents on the spot.\n\n        :return: a list of grid agent.\n        */\n        return this.grid.get_spot_agents(this);\n    }\n    __repr__() {\n        return `<${this.__class__.__name__} 'x': ${this.x}, 'y': ${this.y}, 'colormap': ${this.colormap}, 'payload' : ${this.__dict__}>`;\n    }\n    get_style() {\n        return {\"backgroundColor\": \"#ffffff\"};\n    }\n}\nclass Grid {\n    /*\n    Grid is a widely-used discrete space for ABM.\n    Grid contains many `Spot`s, each `Spot` could contain several agents.\n    */\n    constructor(spot_cls, width, height, wrap = true, caching = true) {\n        /*\n        :param spot_cls: The class of Spot\n        :param width: The width of Grid\n        :param height: The height of Grid\n        :param wrap: If true, the coordinate overflow will be mapped to another end.\n        :param caching: If true, the neighbors and bound check results will be cached to avoid re-computing.\n        */\n        this.width = width;\n        this.height = height;\n        this.wrap = wrap;\n        this._spot_cls = spot_cls;\n        this._existed_agents = {};\n        this._agent_ids = {};\n        this._spots = [];\n        this.caching = caching;\n    }\n    init_grid() {\n        this._spots = function () {\n    var _pj_a = [], _pj_b = range(this.height);\n    for (var _pj_c = 0, _pj_d = _pj_b.length; (_pj_c < _pj_d); _pj_c += 1) {\n        var y = _pj_b[_pj_c];\n        _pj_a.push(function () {\n    var _pj_e = [], _pj_f = range(this.width);\n    for (var _pj_g = 0, _pj_h = _pj_f.length; (_pj_g < _pj_h); _pj_g += 1) {\n        var x = _pj_f[_pj_g];\n        _pj_e.push(new spot_cls(this._convert_to_1d(x, y), x, y));\n    }\n    return _pj_e;\n}\n.call(this));\n    }\n    return _pj_a;\n}\n.call(this);\n        for (var x = 0, _pj_a = this.width; (x < _pj_a); x += 1) {\n            for (var y = 0, _pj_b = this.height; (y < _pj_b); y += 1) {\n                this._spots[y][x].setup();\n            }\n        }\n        if (caching) {\n            this.get_neighbors = functools.lru_cache((this.width * this.height))(this.get_neighbors);\n            this._bound_check = functools.lru_cache((this.width * this.height))(this._bound_check);\n        }\n    }\n    add_category(category_name) {\n        /*\n        Add agent category\n        :param category_name:\n        :return:\n        */\n        this._agent_ids[category_name] = function () {\n    var _pj_a = [], _pj_b = range((this.width * this.height));\n    for (var _pj_c = 0, _pj_d = _pj_b.length; (_pj_c < _pj_d); _pj_c += 1) {\n        var i = _pj_b[_pj_c];\n        _pj_a.push(set());\n    }\n    return _pj_a;\n}\n.call(this);\n        this._existed_agents[category_name] = {};\n    }\n    get_spot(x, y) {\n        /*\n        Get a ``Spot`` at position ``(x, y)``\n\n        :param x:\n        :param y:\n        :return: The ``Spot`` at position (x, y)\n        */\n        [x, y] = this._bound_check(x, y);\n        return this._spots[y][x];\n    }\n    get_agent_ids(category, x, y) {\n        /*\n        Get all agent of a specific category from the spot at (x, y)\n        :param category:\n        :param x:\n        :param y:\n        :return: A set of int, the agent ids.\n        */\n        var agent_ids;\n        agent_ids = this._agent_ids[category][this._convert_to_1d(x, y)];\n        if ((agent_ids === null)) {\n            throw new KeyError(`Category ${category} not registered!`);\n        }\n        return agent_ids;\n    }\n    _convert_to_1d(x, y) {\n        return ((x * this.height) + y);\n    }\n    _in_bounds(x, y) {\n        return (((0 <= x) && (x < this.width)) && ((0 <= y) && (y <= this.height)));\n    }\n    _get_category_of_agents(category_name) {\n        var category;\n        category = this._existed_agents.get(category_name);\n        if ((category === null)) {\n            throw new ValueError(`Category ${category_name} is not registered!`);\n        }\n        return category;\n    }\n    _bound_check(x, y) {\n        if (this.wrap) {\n            return this.coords_wrap(x, y);\n        }\n        if ((! ((0 <= x) && (x < this.width)))) {\n            throw new IndexError(\"grid index x was out of range\");\n        } else {\n            if ((! ((0 <= y) && (y <= this.height)))) {\n                throw new IndexError(\"grid index y was out of range\");\n            } else {\n                return [x, y];\n            }\n        }\n    }\n    coords_wrap(x, y) {\n        /*\n        Wrap the coordination\n        :param x:\n        :param y:\n        :return:\n        */\n        var x_wrapped, y_wrapped;\n        [x_wrapped, y_wrapped] = [(x % this.width), (y % this.height)];\n        x_wrapped = ((x_wrapped >= 0) ? x_wrapped : (this.width + x_wrapped));\n        y_wrapped = ((y_wrapped >= 0) ? y_wrapped : (this.height + y_wrapped));\n        return [x_wrapped, y_wrapped];\n    }\n    _get_neighbor_positions(x, y, radius = 1, moore = true, except_self = true) {\n        /*\n        Get the neighbors of some spot.\n\n        :param x:\n        :param y:\n        :param radius:\n        :param moore:\n        :param except_self:\n        :return:\n        */\n        var neighbors;\n        [x, y] = this._bound_check(x, y);\n        neighbors = [];\n        for (var dx = (- radius), _pj_a = (radius + 1); (dx < _pj_a); dx += 1) {\n            for (var dy = (- radius), _pj_b = (radius + 1); (dy < _pj_b); dy += 1) {\n                if (((! moore) && ((abs(dx) + abs(dy)) > radius))) {\n                    continue;\n                }\n                if (((! this.wrap) && (! this._in_bounds((x + dx), (y + dy))))) {\n                    continue;\n                }\n                if ((((dx === 0) && (dy === 0)) && except_self)) {\n                    continue;\n                }\n                neighbors.append(this._bound_check((x + dx), (y + dy)));\n            }\n        }\n        return neighbors;\n    }\n    _get_neighborhood(x, y, radius = 1, moore = true, except_self = true) {\n        /*\n        Get all spots around (x, y)\n\n        */\n        var neighbor_positions, spots;\n        neighbor_positions = this._get_neighbor_positions(x, y, radius, moore, except_self);\n        spots = [];\n        for (var pos, _pj_c = 0, _pj_a = neighbor_positions, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {\n            pos = _pj_a[_pj_c];\n            [x, y] = pos;\n            spots.append(this.get_spot(x, y));\n        }\n        return spots;\n    }\n    get_agent_neighborhood(agent, radius = 1, moore = true, except_self = true) {\n        return this._get_neighborhood(agent.x, agent.y, radius, moore, except_self);\n    }\n    get_spot_neighborhood(spot, radius = 1, moore = true, except_self = true) {\n        return this._get_neighborhood(spot.x, spot.y, radius, moore, except_self);\n    }\n    add_agent(agent_id, category, x, y) {\n        /*\n        Add agent onto the grid\n        :param agent_id:\n        :param category:\n        :param x:\n        :param y:\n        :return:\n        */\n        var category_of_agents;\n        [x, y] = this._bound_check(x, y);\n        category_of_agents = this._get_category_of_agents(category);\n        if (_pj.in_es6(agent_id, category_of_agents.keys())) {\n            throw new ValueError(`Agent with id: ${agent_id} already exists on grid!`);\n        }\n        if (_pj.in_es6(agent_id, this._agent_ids[category][this._convert_to_1d(x, y)])) {\n            throw new ValueError(`Agent with id: ${agent_id} already exists at position ${[x, y]}!`);\n        } else {\n            this._agent_ids[category][this._convert_to_1d(x, y)].add(agent_id);\n            this._existed_agents[category][agent_id] = [x, y];\n        }\n    }\n    _remove_agent(agent_id, category, x, y) {\n        var category_of_agents;\n        [x, y] = this._bound_check(x, y);\n        category_of_agents = this._get_category_of_agents(category);\n        if ((! _pj.in_es6(agent_id, category_of_agents.keys()))) {\n            throw new ValueError(`Agent with id: ${agent_id} does not exist on grid!`);\n        }\n        if ((! _pj.in_es6(agent_id, this._existed_agents[category]))) {\n            throw new ValueError(\"Agent does not exist on the grid!\");\n        }\n        if ((! _pj.in_es6(agent_id, this._agent_ids[category][this._convert_to_1d(x, y)]))) {\n            console.log(\"Melodie-boost error occured. agent_id:\", agent_id, \"x:\", x, \"y:\", y);\n            throw new IndexError(\"agent_id does not exist on such coordinate.\");\n        } else {\n            this._agent_ids[category][this._convert_to_1d(x, y)].remove(agent_id);\n            this._existed_agents[category].pop(agent_id);\n        }\n    }\n    remove_agent(agent_id, category) {\n        /*\n        Remove agent from the grid\n        :param agent_id:\n        :param category:\n        :return:\n        */\n        var source_x, source_y;\n        [source_x, source_y] = this.get_agent_pos(agent_id, category);\n        this._remove_agent(agent_id, category, source_x, source_y);\n    }\n    move_agent(agent_id, category, target_x, target_y) {\n        /*\n        Move agent to target position.\n        :param agent_id:\n        :param category:\n        :param target_x:\n        :param target_y:\n        :return:\n        */\n        var source_x, source_y;\n        [source_x, source_y] = this.get_agent_pos(agent_id, category);\n        this._remove_agent(agent_id, category, source_x, source_y);\n        this.add_agent(agent_id, category, target_x, target_y);\n    }\n    get_agent_pos(agent_id, category) {\n        /*\n        Get the agent position at the grid.\n        :param agent_id:\n        :param category:\n        :return:\n        */\n        return this._existed_agents[category][agent_id];\n    }\n    to_2d_array(attr_name) {\n        /*\n        Collect attribute of each spot and write the attribute value into an 2d np.array.\n        Notice:\n        - The attribute to collect should be float/int/bool, not other types such as str.\n        - If you would like to get an element from the returned array, please write like this:\n        ```python\n        arr = self.to_2d_array('some_attr')\n        y = 10\n        x = 5\n        spot_at_x_5_y_10 = arr[y][x] # CORRECT. Get the some_attr value of spot at `x = 5, y = 10`\n        spot_at_x_5_y_10 = arr[x][y] # INCORRECT. You will get the value of spot at `x = 10, y = 5`\n        ```\n        :param attr_name: the attribute name to collect for this model.\n        :return:\n        */\n        return vectorize_2d(this._spots, attr_name);\n    }\n    get_roles() {\n        var grid_roles, pos_1d, spot;\n        grid_roles = np.zeros([(this.height * this.width), 4]);\n        for (var x = 0, _pj_a = this.width; (x < _pj_a); x += 1) {\n            for (var y = 0, _pj_b = this.height; (y < _pj_b); y += 1) {\n                spot = this.get_spot(x, y);\n                pos_1d = this._convert_to_1d(x, y);\n                grid_roles[[pos_1d, 0]] = x;\n                grid_roles[[pos_1d, 1]] = y;\n                grid_roles[[pos_1d, 2]] = 0;\n                grid_roles[[pos_1d, 3]] = spot.role;\n            }\n        }\n        return grid_roles;\n    }\n}\n\n\n//# sourceMappingURL=grid.js.map\n\n\n//# sourceURL=webpack://leetcode/./MelodieInfra/core/grid.js?");

/***/ }),

/***/ "./MelodieInfra/core/main.js":
/*!***********************************!*\
  !*** ./MelodieInfra/core/main.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _agent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./agent */ \"./MelodieInfra/core/agent.js\");\n/* harmony import */ var _environment__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./environment */ \"./MelodieInfra/core/environment.js\");\n/* harmony import */ var _agent_list__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./agent_list */ \"./MelodieInfra/core/agent_list.js\");\n/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./model */ \"./MelodieInfra/core/model.js\");\n/* harmony import */ var _scenario__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./scenario */ \"./MelodieInfra/core/scenario.js\");\n/* harmony import */ var _patch__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./patch */ \"./MelodieInfra/core/patch.ts\");\n/* harmony import */ var _grid__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./grid */ \"./MelodieInfra/core/grid.js\");\n\n\n\n\n\n\n\nwindow.Agent = _agent__WEBPACK_IMPORTED_MODULE_0__.Agent;\nwindow.Environment = _environment__WEBPACK_IMPORTED_MODULE_1__.Environment;\nwindow.Model = _model__WEBPACK_IMPORTED_MODULE_3__.Model;\nwindow.AgentList = _agent_list__WEBPACK_IMPORTED_MODULE_2__.AgentList\nwindow.Scenario = _scenario__WEBPACK_IMPORTED_MODULE_4__.Scenario\nwindow.Grid = _grid__WEBPACK_IMPORTED_MODULE_6__.Grid;\nwindow.Spot = _grid__WEBPACK_IMPORTED_MODULE_6__.Spot;\nwindow.GridAgent = _grid__WEBPACK_IMPORTED_MODULE_6__.GridAgent;\nwindow.GridItem = _grid__WEBPACK_IMPORTED_MODULE_6__.GridItem\n;(0,_patch__WEBPACK_IMPORTED_MODULE_5__.patch)()\n;(0,_patch__WEBPACK_IMPORTED_MODULE_5__.patchAgentList)(_agent_list__WEBPACK_IMPORTED_MODULE_2__.AgentList)\n\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({ Agent: _agent__WEBPACK_IMPORTED_MODULE_0__.Agent, Environment: _environment__WEBPACK_IMPORTED_MODULE_1__.Environment, AgentList: _agent_list__WEBPACK_IMPORTED_MODULE_2__.AgentList, Model: _model__WEBPACK_IMPORTED_MODULE_3__.Model });//, AgentList }\n\n//# sourceURL=webpack://leetcode/./MelodieInfra/core/main.js?");

/***/ }),

/***/ "./MelodieInfra/core/model.js":
/*!************************************!*\
  !*** ./MelodieInfra/core/model.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Model\": () => (/* binding */ Model)\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./MelodieInfra/core/types.js\");\n/* harmony import */ var _agent_list__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./agent_list */ \"./MelodieInfra/core/agent_list.js\");\n/* harmony import */ var _agent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./agent */ \"./MelodieInfra/core/agent.js\");\n/* harmony import */ var _environment__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./environment */ \"./MelodieInfra/core/environment.js\");\n\n\n\n\nclass ModelRunRoutine {\n    /*\n    A simple iterator for model run.\n\n\n    When calling ``Model.iterator()`` method, a ModelRunRoutine object will be created, yielding an ``int``  value\n    reprensenting the current number of step, ranging ``[0, max_step - 1]``.\n\n\n    */\n    constructor(max_step, model) {\n        this._current_step = (- 1);\n        this._max_step = max_step;\n        this.model = model;\n    }\n    __iter__() {\n        return this;\n    }\n    __next__() {\n        if ((this._current_step >= (this._max_step - 1))) {\n            throw StopIteration;\n        }\n        this.model._visualizer_step(this._current_step);\n        this._current_step += 1;\n        return this._current_step;\n    }\n    __del__() {\n        /*\n        Remove circular reference before deletion\n\n        :return:\n        */\n        this.model = null;\n    }\n}\nclass Model {\n    constructor(config, scenario, run_id_in_scenario = 0, visualizer = null) {\n        this.scenario = scenario;\n        this.config = config;\n        this.environment = null;\n        this.data_collector = null;\n        this.table_generator = null;\n        this.run_id_in_scenario = run_id_in_scenario;\n        this.network = null;\n        this.visualizer = visualizer;\n        this.initialization_queue = [];\n    }\n    __del__() {\n        /*\n        Remove circular reference before deletion\n\n        :return:\n        */\n        this.visualizer = null;\n    }\n    create() {\n        /*\n        An initialization method, which is called immediately right after the ``Model`` object is created.\n\n        :return: None\n        */\n    }\n    setup() {\n        /*\n        General method for model setup, which is called after ``Model.create()``\n\n        :return: None\n        */\n    }\n    create_db_conn() {\n        /*\n        Create a database connection with the project configuration.\n\n        :return: DBConn object\n        */\n        return create_db_conn(this.config);\n    }\n    create_agent_list(agent_class) {\n        /*\n        Create an agent list object. A model could contain multiple ``AgentList``s.\n\n        :param agent_class: The class of desired agent type.\n        :return: Agentlist object created\n        */\n        return new _agent_list__WEBPACK_IMPORTED_MODULE_1__.AgentList(agent_class, {\"model\": this});\n    }\n    create_environment(env_class) {\n        /*\n        Create the environment of model. Notice that a model has only one environment.\n\n        :param env_class:\n        :return: Environment object created\n        */\n        var env;\n        env = env_class();\n        env.model = this;\n        env.scenario = this.scenario;\n        this.initialization_queue.append(env);\n        return env;\n    }\n    create_grid(grid_cls = null, spot_cls = null) {\n        /*\n        Create a grid.\n\n        :param grid_cls: The class of grid, ``Melodie.Grid`` by default.\n        :param spot_cls: The class of spot, ``Melodie.Spot`` by default.\n        :return: Grid object.\n        */\n        var grid;\n        grid_cls = ((grid_cls !== null) ? grid_cls : Grid);\n        spot_cls = ((spot_cls !== null) ? spot_cls : Spot);\n        grid = grid_cls(spot_cls, this.scenario);\n        this.initialization_queue.append(grid);\n        return grid;\n    }\n    create_network(network_cls = null, edge_cls = null) {\n        /*\n        Create the network of model.\n\n        :param network_cls: The type of network object, ``Melodie.Network`` by default.\n        :param edge_cls: The type of edge object, ``Melodie.Edge`` by default.\n        :return: Network object created\n        */\n        var network;\n        if ((network_cls === null)) {\n            network_cls = Network;\n        }\n        network = network_cls(edge_cls);\n        this.initialization_queue.append(network);\n        return network;\n    }\n    create_data_collector(data_collector_cls) {\n        /*\n        Create the data collector of model.\n\n        :param data_collector_cls: The datacollector class, must be a custom class inheriting ``Melodie.DataCollector``.\n        :return: Datacollector object created.\n        */\n        var data_collector;\n        data_collector = data_collector_cls();\n        data_collector.model = this;\n        data_collector.scenario = this.scenario;\n        this.initialization_queue.append(data_collector);\n        return data_collector;\n    }\n    create_agent_container(agent_class, initial_num, params_df = null, container_type = \"list\") {\n        /*\n        Create a container for agents.\n\n        :param agent_class:\n        :param initial_num: Initial number of agents\n        :param params_df:   Pandas DataFrame\n        :param container_type: a str, \"list\" or \"dict\"\n        :return: Agent container created\n        */\n        var agent_container_class, container;\n        agent_container_class = None;\n        if ((container_type === \"list\")) {\n            agent_container_class = _agent_list__WEBPACK_IMPORTED_MODULE_1__.AgentList;\n        } else {\n            if ((container_type === \"dict\")) {\n                agent_container_class = AgentDict;\n            } else {\n                throw new NotImplementedError(`Container type '${container_type}' is not valid!`);\n            }\n        }\n        container = agent_container_class(agent_class, {\"model\": this});\n        if ((params_df !== null)) {\n            container.set_properties(params_df);\n        } else {\n            show_prettified_warning((`No dataframe set for the ${agent_container_class.__name__}.\n`\n + show_link()));\n        }\n        this.initialization_queue.append(container);\n        return container;\n    }\n    run() {\n        /*\n        Model run. Be sure to inherit this method on your model.\n\n        :return: None\n        */\n    }\n    iterator(period_num) {\n        /*\n        Return an iterator which iterates from `0` to `period_num-1`. In each iteration, the iterator updates the\n        visualizer if it exists.\n\n        :param period_num: How many periods will this model run.\n        :return: None\n        */\n        return new ModelRunRoutine(period_num, this);\n    }\n    _visualizer_step(current_step) {\n        /*\n        If visualizer is defined, make it step.\n\n        :param current_step:\n        :return:\n        */\n        if (((this.visualizer !== null) && (current_step > 0))) {\n            this.visualizer.step(current_step);\n        }\n    }\n    init_visualize() {\n        /*\n        Be sure to implement it if you would like to use visualizer.\n\n        :return:\n        */\n    }\n    _setup() {\n        /*\n        Wrapper of setup()\n\n        :return:\n        */\n        this.create();\n        this.setup();\n        for (var component_to_init, _pj_c = 0, _pj_a = this.initialization_queue, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {\n            component_to_init = _pj_a[_pj_c];\n            component_to_init._setup();\n        }\n    }\n}\n\n\n//# sourceMappingURL=model.js.map\n\n\n//# sourceURL=webpack://leetcode/./MelodieInfra/core/model.js?");

/***/ }),

/***/ "./MelodieInfra/core/scenario.js":
/*!***************************************!*\
  !*** ./MelodieInfra/core/scenario.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Scenario\": () => (/* binding */ Scenario)\n/* harmony export */ });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./MelodieInfra/core/types.js\");\n/* harmony import */ var _agent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./agent */ \"./MelodieInfra/core/agent.js\");\n\n\nvar _pj;\nfunction _pj_snippets(container) {\n    function in_es6(left, right) {\n        if (((right instanceof Array) || ((typeof right) === \"string\"))) {\n            return (right.indexOf(left) > (- 1));\n        } else {\n            if (((right instanceof Map) || (right instanceof Set) || (right instanceof WeakMap) || (right instanceof WeakSet))) {\n                return right.has(left);\n            } else {\n                return (left in right);\n            }\n        }\n    }\n    container[\"in_es6\"] = in_es6;\n    return container;\n}\n_pj = {};\n_pj_snippets(_pj);\nclass Scenario extends _agent__WEBPACK_IMPORTED_MODULE_1__.Element {\n    /*\n    Scenario contains a set of parameters used in simulation model.\n    It is created before the initialization of ``Model``.\n\n    */\n    constructor(id_scenario = null) {\n        /*\n        :param id_scenario: the id of scenario. if None, this will be self-increment from 0 to scenarios_number-1\n        */\n        super();\n        this._parameters = [];\n        this.manager = null;\n        this.id = id_scenario;\n        this.run_num = 1;\n        this.period_num = 0;\n    }\n    copy() {\n        /*\n        Copy current scenario to a new scenario.\n\n        :return: New scenario object.\n        */\n        var new_scenario, property;\n        new_scenario = this.__class__();\n        for (var property_name, _pj_c = 0, _pj_a = this.__dict__.keys(), _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {\n            property_name = _pj_a[_pj_c];\n            property = this.__dict__[property_name];\n            new_scenario[property_name] = property;\n        }\n        for (var parameter, _pj_c = 0, _pj_a = this._parameters, _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {\n            parameter = _pj_a[_pj_c];\n            parameter.init = this[parameter.name];\n        }\n        return new_scenario;\n    }\n    setup() {\n        /*\n        Setup method, be sure to inherit it on the custom scenario class.\n        */\n    }\n    to_dict() {\n        /*\n        Convert this scenario object to a dict.\n\n        :return: A ``dict``, ``property_name->property_value``\n        */\n        var d, v;\n        d = {};\n        for (var k, _pj_c = 0, _pj_a = this.__dict__.keys(), _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {\n            k = _pj_a[_pj_c];\n            v = this.__dict__[k];\n            d[k] = v;\n        }\n        return d;\n    }\n    to_json() {\n        /*\n        Convert this scenario to a dict without concerning non-serializable properties.\n\n        :return: a ``dict``, ``property_name->property_value``, without non-serializable properties\n        */\n        var d;\n        d = {};\n        for (var k, _pj_c = 0, _pj_a = this.__dict__.keys(), _pj_b = _pj_a.length; (_pj_c < _pj_b); _pj_c += 1) {\n            k = _pj_a[_pj_c];\n            if ((! _pj.in_es6(k, [\"manager\"]))) {\n                d[k] = this.__dict__[k];\n            }\n        }\n        return d;\n    }\n    __repr__() {\n        return `<${this.__class__.__name__} ${this.__dict__}>`;\n    }\n}\n\n\n//# sourceMappingURL=scenario.js.map\n\n\n//# sourceURL=webpack://leetcode/./MelodieInfra/core/scenario.js?");

/***/ }),

/***/ "./MelodieInfra/core/types.js":
/*!************************************!*\
  !*** ./MelodieInfra/core/types.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Any\": () => (/* binding */ Any),\n/* harmony export */   \"Dict\": () => (/* binding */ Dict),\n/* harmony export */   \"List\": () => (/* binding */ List),\n/* harmony export */   \"Optional\": () => (/* binding */ Optional),\n/* harmony export */   \"Set\": () => (/* binding */ Set),\n/* harmony export */   \"TYPE_CHECKING\": () => (/* binding */ TYPE_CHECKING)\n/* harmony export */ });\n\nconst TYPE_CHECKING = 0;\nconst Any = 0;\nconst Dict = 0;\nconst List = 0;\nconst Optional = 0;\nconst Set = 0;\n\n//# sourceURL=webpack://leetcode/./MelodieInfra/core/types.js?");

/***/ }),

/***/ "./MelodieInfra/core/patch.ts":
/*!************************************!*\
  !*** ./MelodieInfra/core/patch.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"patch\": () => (/* binding */ patch),\n/* harmony export */   \"patchAgentList\": () => (/* binding */ patchAgentList)\n/* harmony export */ });\nfunction patchArrayMethods() {\n    Array.prototype['append'] = Array.prototype.push;\n}\nfunction patchAgentList(AgentList) {\n    AgentList.prototype[Symbol.iterator] = function () {\n        var index = 0;\n        var data = this.agents;\n        return {\n            next: function () {\n                return { value: data[++index], done: !(index in data) };\n            }\n        };\n    };\n}\nfunction patch() {\n    patchArrayMethods();\n}\nwindow['time'] = {\n    time: function () { return Date.now() / 1000.0; }\n};\nwindow['random'] = {\n    random: Math.random,\n    randint: function (a, b) {\n        return Math.floor(Math.random() * (b - a + 1)) + a;\n    },\n    normalvariate: function (mu, sigma) {\n        if (mu === void 0) {\n            mu = 0;\n        }\n        if (sigma === void 0) {\n            sigma = 1;\n        }\n        var x, y, r;\n        do {\n            x = Math.random() * 2 - 1;\n            y = Math.random() * 2 - 1;\n            r = x * x + y * y;\n        } while (!r || r > 1);\n        return mu + sigma * y * Math.sqrt(-2 * Math.log(r) / r);\n    }\n};\nfunction create2DArray(height, width) {\n    var arr = [];\n    for (var i_1 = 0; i_1 < height; i_1++) {\n        var row = [];\n        for (var j = 0; j < width; j++) {\n            row.push(null);\n        }\n        arr.push(row);\n    }\n    return arr;\n}\nfunction unmarshallModel(data) {\n    var model = new (eval(data.model_cls))();\n    // model.setup()\n    model.scenario = new (eval(data.scenario['cls']))();\n    for (var k in data.scenario.data) {\n        model.scenario[k] = data.scenario.data[k];\n    }\n    for (var _i = 0, _a = data.components; _i < _a.length; _i++) {\n        var component = _a[_i];\n        if (component.type == \"environment\") {\n            model.environment = new (eval(component['cls']))();\n        }\n        else if (component.type == \"agent_list\") {\n            model[component.prop_name] = new (eval(component['cls']))((eval(component['agent_cls'])), component['agents'].length, model);\n            var agents = [];\n            var agent_cls = eval(component['agent_cls']);\n            for (var _b = 0, _c = component['agents']; _b < _c.length; _b++) {\n                var agent_data = _c[_b];\n                var agent = new agent_cls();\n                for (var k in agent_data) {\n                    agent[k] = agent_data[k];\n                }\n                agent.model = model;\n                agents.push(agent);\n            }\n            model[component.prop_name].agents = agents;\n        }\n        else if (component.type == 'grid') {\n            var grid = new (eval(component['cls']))((eval(component.spot_cls)), component.width, component.height, model);\n            model[component.prop_name] = grid;\n            grid._spots = create2DArray(component.height, component.width);\n            var spot_type = (eval(component['spot_cls']));\n            for (var _d = 0, _e = component.spots; _d < _e.length; _d++) {\n                var spotData = _e[_d];\n                var y_1 = spotData.y, x_1 = spotData.x;\n                var spot = new spot_type();\n                for (var k in spotData) {\n                    spot[k] = spotData[k];\n                }\n                spot.model = model;\n                grid._spots[y_1][x_1] = spot;\n            }\n        }\n    }\n    return model;\n}\nwindow['unmarshallModel'] = unmarshallModel;\n\n\n//# sourceURL=webpack://leetcode/./MelodieInfra/core/patch.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./MelodieInfra/core/main.js");
/******/ 	
/******/ })()
;