from typing import TYPE_CHECKING, Any, List, Callable

if TYPE_CHECKING:
    from Melodie.agent import Agent


def assert_exc_occurs(exc_id: int, func: Callable):
    try:
        func()
        assert False
    except MelodieException as e:
        assert e.id == exc_id


class MelodieException(Exception):
    def __init__(self, exc_id: int, text: str):
        text = f'{text} <Error ID {exc_id}>'
        super(MelodieException, self).__init__(text)
        self.id = exc_id


class MelodieExceptions:
    class State:
        ID = 1100

        @staticmethod
        def StateNotFoundError(state, all_states):
            return MelodieException(1101,
                                    f'State {repr(state)} is not defined. All states are: {all_states}')

        @staticmethod
        def CannotMoveToNewStateError(old_state, new_state, all_possible_new_states: set):
            if len(list(all_possible_new_states)) == 0:
                return MelodieException(1102,
                                        f'Current state is {repr(old_state)}, on which the status could only move to'
                                        f' itself. However the new state was {repr(new_state)}')
            else:
                return MelodieException(1102,
                                        f'Current state is {repr(old_state)}, on which the status could only move to'
                                        f' {all_possible_new_states}. However the new state was {repr(new_state)}')

        @staticmethod
        def NotAStateAttributeError(agent_cls, state_attr: str):
            return MelodieException(1103, f'Class {agent_cls} has not defined state attribute {state_attr}')

    class Scenario:
        ID = 1200

        @staticmethod
        def ScenarioIDDuplicatedError(scenario_id):
            return MelodieException(1201, f'Scenario id {scenario_id} was duplicated, which is not allowed.')

        @staticmethod
        def ScenarioIDTypeError(scenario_id):
            return MelodieException(1202,
                                    f'Scenario id {scenario_id} should be int or str. However its type was {type(scenario_id)}.')

        @staticmethod
        def ScenarioIDNotAllNoneError(scenario_id_nones: int, scenario_nums: int):
            return MelodieException(1203,
                                    f'{scenario_id_nones} scenario(s) has/have id None, However there are totally {scenario_nums} scenarios.\n'
                                    f'If you would like to use self-increment user ids, please make sure all scenarios has id of None!')

        @staticmethod
        def NoValidScenarioGenerated(scenarios):
            return MelodieException(1204,
                                    f'The scenario manager has not generated any valid scenarios. '
                                    f'The scenarios generated by gen_scenarios() was {scenarios},'
                                    f'please make sure gen_scenarios() returns a list of Scenario.')

        @staticmethod
        def ScenariosIsEmptyList():
            return MelodieException(1205,
                                    f'The scenario manager generated an empty scenario list. '
                                    f'Please make sure gen_scenarios() returns a list of Scenario.')

        @staticmethod
        def ScenarioIDNotOfSameTypeError(id1, id2_type):
            return MelodieException(1206,
                                    f'Scenario id should be of same type, however types {type(id1)} and {id2_type}'
                                    f' detected. ')

        @staticmethod
        def ScenarioListItemTypeError(item):
            return MelodieException(1207,
                                    f'Scenario list elements are not Scenario() but a {type(item)} object with value {item}')

        @staticmethod
        def NoScenarioSheetInExcel(file_name: str):
            return MelodieException(1208, f'Melodie excel file {file_name} should have a sheet named \'scenarios\' ')

        # @staticmethod
        # def UnusedTableInExcel(excel_file_name: str, other_sheets: List[str]):
        #     return MelodieException(1209,
        #                             f'Melodie detected you used \'agent_params\' sheet to assign same parameter to agents in '
        #                             f'despite scenario changes. However in this case there is/are other sheet(s) {other_sheets} '
        #                             f'in the excel file {excel_file_name} which is not allowed in Melodie.')

        @staticmethod
        def ExcelAgentParamsRecordCountNotConsistentToScneario(scenario_id, scenario_agents_num: int, param_table_name,
                                                               param_num: int):
            return MelodieException(1209,
                                    f'Agent parameter sheet `{param_table_name}` contains {param_num} agents\' parameter records.\n'
                                    f'However `scenarios` sheet says there should be {scenario_agents_num}  agents '
                                    f'initially in the scenario {scenario_id}.')

        @staticmethod
        def ExcelLackAgentParamsSheet(agent_param_sheet_name, ):
            return MelodieException(1210,
                                    f"Excel file lacks agent parameter sheet `{agent_param_sheet_name}`")

    class Agents:
        ID = 1300

        @staticmethod
        def AgentManagerEmpty(agent_manager):
            return MelodieException(1301, f'Agent manager {agent_manager} contains no agents!')

        @staticmethod
        def AgentPropertyNameNotExist(property_name, agent):
            return MelodieException(1301,
                                    f'Agent {agent} does not have property {property_name}. All properties are:{list(agent.__dict__.keys())}')

    class Environment:
        ID = 1400

        @staticmethod
        def NoAgentManagerDefined(environment):
            return MelodieException(1401,
                                    f'Environment {environment} has no AgentManager defined, which is not allowed!')

    class Data:
        ID = 1500

        @staticmethod
        def TableNameAlreadyExists(table_name: str, existed: str):
            return MelodieException(1501,
                                    f'Table Named {table_name} does not exist. All existed tables are: {existed}')
